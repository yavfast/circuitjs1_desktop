# Trigger-mode для осцилографа (як у реальних осцилографах)

Дата: 2025-12-15

## Мета
Додати до вбудованого осцилографа CircuitJS1 «реальний» режим відображення (triggered acquisition), щоб сигнал був стабільно «прибитий» по тригеру, а користувач міг керувати:
- тригером (джерело, рівень, фронт, режими Auto/Normal/Single, holdoff)
- часом розгортки (timebase, sec/div)
- зміщенням (горизонтальна позиція тригера / pre-trigger, а також вертикальна позиція каналу)

Примітка: окремі «вимірювання відносно нуля/певної точки схеми» у Scope поки не додаємо, бо референс (який саме пін/вузол) неоднозначний. Для цього буде використовуватись окремий елемент-індикатор.

Ціль: поведінка максимально схожа на побутові DSO, але без втручання в сам симулятор (переважно на рівні буферів Scope).

## Поточний стан (коротко)
Зараз Scope працює як «rolling buffer» (по суті, Roll/free-run режим):
- `ScopePlot` накопичує `minValues[]/maxValues[]` у кільцевому буфері та рухає `ptr` з кроком `maxTimeStep * scopePlotSpeed`.
- Відображення прив’язане до «поточного часу» симуляції: правий край — це “now”, а по X показуються останні `rect.width` семплів.
- Є керування timebase через `speed` (timestep units per pixel) + розрахунок `gridStepX`.
- Є ручний вертикальний масштаб і вертикальна позиція (`manScale`, `manVPosition`), а також курсор часу та вимірювання RMS/AVG/Duty/Freq.
- Тригера як механізму «вирівнювання кадрів» немає.
- Є FFT режим (`showFFT`), який будує спектр та має власну логіку курсора/підписів.

Вимога сумісності: новий trigger-mode має бути додатковим, а існуючі Roll та FFT режими повинні зберегтися без регресій.

## Поняття та терміни
- **Acquisition buffer**: кільцевий буфер семплів, який постійно наповнюється.
- **Trigger source**: канал/плот, по якому шукаємо подію (CH1/CH2/…).
- **Trigger level**: рівень (у V/A/…) для порогу.
- **Slope**: фронт — `Rising` або `Falling`.
- **Trigger position**: де на екрані стоїть подія тригера (наприклад 50% — посередині; 20% — ближче до лівого краю; 80% — ближче до правого).
- **Holdoff**: мінімальний час між спрацьовуваннями, щоб уникати «дьоргання».
- **Trigger mode**:
  - `AUTO`: якщо тригер не знаходиться — показує free-run (як зараз).
  - `NORMAL`: якщо тригера немає — не оновлює кадр (чекає).
  - `SINGLE`: після першого успішного тригера «заморожує» кадр.

## UX/поведінка, яку треба отримати
### 0) Режими відображення (що має залишитись)
- **Roll (існуючий)**: поточний free-run/rolling графік, як зараз.
- **Trigger (новий)**: стабілізація кадру по тригеру (тільки для time-domain відображення).
- **FFT (існуючий)**: спектр (режим `showFFT`), без участі тригера.

### 1) Режими захоплення (Run control)
- **Run/Stop** для scope (не для всього симулятора):
  - Run: буфер оновлюється і кадр перераховується.
  - Stop: кадр зафіксований, але симуляція може продовжуватись.
- **Single**: «Armed» → перший trigger → freeze.

### 2) Тригер
- Візуальні маркери:
  - лінія рівня тригера (горизонтальна) на trigger source каналі
  - маркер позиції тригера по X (вертикальна рисочка/стрілка згори)
  - індикатор стану: `AUTO`, `READY`, `TRIG'D`, `STOP`.

Примітка про сумісність: якщо увімкнено `showFFT` або XY/2D режими, trigger-controls мають бути disabled/ignored, а відображення працює як і раніше.

### 3) Розгортка (timebase)
- Timebase керується дискретними кроками 1–2–5 (як DSO), відображається як `H=.../div`.
- Зміна timebase не ламає буфер: просто інша “віконна” вибірка при рендерінгу.

### 4) Зміщення
- **Горизонтальне**: `triggerPosition` (pre-trigger/post-trigger) — подія тригера повинна з’являтися в заданій колонці по X.
- **Вертикальне**: позиція каналу (зсув відносно нульової лінії). Бажано працює і в Auto-scale (не тільки manual).

### 5) Накладання кількох осцилограм одного каналу (History/Persistence)
Потрібно передбачити можливість накладання декількох осцилограм з одного каналу, щоб бачити динаміку змін сигналу між захопленнями.

Мінімальний UX (без зайвих «плюшок»):
- `History/Persistence: Off/On`
- `Depth`: кількість збережених осцилограм (N)
- `Capture`: автоматично при кожному trigger (у Trigger-режимі) або вручну кнопкою `Capture`
- `Clear`: очистити історію

Обмеження/сумісність:
- Накладання має працювати лише для time-domain (Roll/Trigger), ігноруватись у FFT/XY/2D.
- Накладання робиться для одного вибраного каналу/плоту (наприклад trigger source або активний канал у діалозі).

## Технічний дизайн (мінімально інвазивний)
### A) Дані та налаштування
Додати в `Scope` структуру налаштувань тригера (можна як вкладений клас або окремий файл):
- `boolean triggerEnabled`
- `TriggerMode triggerMode` (`AUTO|NORMAL|SINGLE`)
- `TriggerState triggerState` (`RUNNING|ARMED|TRIGGERED|STOPPED`)
- `int triggerSourcePlotIndex` (індекс у `visiblePlots`, або стабільний ID)
- `TriggerSlope slope` (`RISING|FALLING`)
- `double triggerLevel`
- `double triggerHoldoffSec`
- `double triggerPositionFrac` (0..1)
- `double lastTriggerTimeSec` (для holdoff)
- `double autoTimeoutSec` (для AUTO fallback)

Важливо: налаштування мають серіалізуватись у dump/undump (як зараз робиться для `showFreq`, `showRMS`, `plotFlags`, і т.д.).

### B) Буфер семплів: що потрібно для якісного trigger detect
Проблема: зараз зберігаються тільки `minValues[]/maxValues[]` на “піксель-інтервал” часу. Для стабільного визначення фронту бажано мати “репрезентативне значення” на кожен індекс.

Пропозиція:
- Додати в `ScopePlot` масив `double[] sampleValues` (наприклад “останнє значення у цьому bucket”, або “середнє”).
- У `timeStep()` оновлювати `sampleValues[ptr] = v` (до/після AC coupling залежно від того, по чому тригеримо).

Це дасть нормальне детектування перетину `level` між `sampleValues[i-1]` та `sampleValues[i]`.

### C) Алгоритм пошуку тригера (на етапі рендеру)
Мета: не змінювати наповнення буфера, а лише вибирати “вікно” даних для показу.

Обмеження/сумісність:
- Trigger-mode застосовується тільки для звичайного time-domain відображення.
- Для FFT (`showFFT==true`) та XY/2D відображень trigger логіка не виконується, використовується існуючий код.

1) Визначити trigger source plot `p`.
2) Визначити “час одного індексу”:
   - $\Delta t = maxTimeStep \cdot speed$ (це вже використовується для X grid).
3) Порахувати скільки індексів в кадрі: `W = rect.width`.
4) Розрахувати, скільки семплів має бути “до тригера”:
   - `pre = round(W * triggerPositionFrac)`
   - trigger має опинитись у колонці `pre` (від лівого краю).
5) Вибрати пошукове вікно у буфері (наприклад останні `W*2` індексів), знайти найближчий “правильний” перетин рівня:
   - rising: `prev < level && cur >= level`
   - falling: `prev > level && cur <= level`
6) Перевірити holdoff:
   - якщо `sim.t - lastTriggerTimeSec < holdoff` — пропустити цей кандидат і шукати далі.
7) Якщо знайдено:
   - `triggerIndex = foundIndex`
   - `startIndex = triggerIndex - pre` (з урахуванням кільцевого буфера)
   - `lastTriggerTimeSec = sim.tCandidate` (або оцінка)
   - для `SINGLE`: freeze (`triggerState=STOPPED`)
8) Якщо не знайдено:
   - `AUTO`: показати free-run як зараз (startIndex = `plot.ptr + spc - W`)
   - `NORMAL`: не оновлювати startIndex (залишити попередній кадр)

Примітка: для багатоканального відображення `startIndex` має бути спільним для всіх `visiblePlots`, інакше канали “роз’їдуться” по часу.

### D) “Freeze” реалізація
Найпростіше:
- У `Scope` зберігати `boolean frozen` + `int frozenStartIndex`.
- У `STOPPED` (або при Stop кнопці) рендер завжди використовує `frozenStartIndex`, а `timeStep()` може продовжувати збирати дані (або можна тимчасово відключити timeStep для цього scope — на вибір).

### E) Накладання (History/Persistence) — як зберігати і малювати
Ціль: зберігати кілька “кадрів” одного каналу і домальовувати їх поверх поточного, щоб було видно розкид/дрейф.

Пропозиція даних:
- У `Scope` додати налаштування:
   - `boolean historyEnabled`
   - `int historyDepth`
   - `HistoryCaptureMode historyCaptureMode` (`AUTO_ON_TRIGGER|MANUAL`)
   - `int historyPlotIndex` (який саме канал/плот)
- Додати структуру `ScopeHistoryFrame` (кадр осцилограми) з полями:
   - `double capturedAtTime`
   - `int startIndex` (для прив’язки до кільцевого буфера)
   - дані для швидкого рендеру

Варіант з найменшим ризиком для продуктивності:
- При захопленні кадру (trigger або manual) попередньо обчислити “піксельні” дані для вибраного plot на ширину `rect.width`:
   - або масив `double[] yValuesPerX` (використовуючи `sampleValues`)
   - або пари `min/max` на X (щоб вигляд збігався з поточним рендером)
- Зберігати не більше `historyDepth` кадрів (FIFO).

Рендер:
- Спочатку малювати history-кадри (старіші — блідіші), потім поточний сигнал.
- Візуальну “прозорість” робити через альфа/інтенсивність (якщо `Graphics` дозволяє), або через альтернативний колір/стиль без додавання нової палітри (наприклад той самий колір каналу, але менш інтенсивний).

Де захоплювати:
- У Trigger-режимі: при кожному успішному trigger (і коли кадр визначено), якщо `historyEnabled` і режим `AUTO_ON_TRIGGER`.
- У Roll-режимі: лише ручний `Capture` (інакше історія буде «заливатись» занадто швидко).

Сумісність:
- Для `showFFT==true` та XY/2D — history не малювати і не наповнювати (або лише не малювати, залежно від простоти).

### F) UI (ScopePropertiesDialog)
Додати новий розділ (expanding section) **Trigger**:
- Enable trigger (checkbox)
- Mode: Auto / Normal / Single (radio)
- Source: CH1/CH2/… (listbox/радіо/кнопки як канали)
- Slope: Rising / Falling
- Level: текстове поле (з units підказкою)
- Holdoff: поле (ms/div або sec)
- Trigger position: slider 0..100% (або окремий повзунок, поряд з current `positionBar` якщо він вертикальний)

Нота: Trigger секція має бути вимкнена/прихована для `plotXY`, `plot2d`, `showFFT` (або показувати, але disabled).

Додати розділ (або підрозділ) **History/Persistence**:
- Enable history (checkbox)
- Depth (число)
- Mode: Auto on trigger / Manual
- Plot/Channel: який канал зберігати (за замовчуванням trigger source)
- Buttons: `Capture`, `Clear`

## План реалізації (поетапно)
### Етап 0 — Специфікація та UX (1–2 ітерації)
- Зафіксувати набір мінімальних опцій першого релізу: `Enable`, `Auto/Normal/Single`, `Source`, `Level`, `Slope`, `Position`.
- Узгодити, чи потрібен “Run/Stop для scope” в першій версії чи достатньо тільки Single.

### Етап 1 — Дані + серіалізація (core)
1) Додати `TriggerSettings` у `Scope`.
2) Додати поля, дефолти, dump/undump.
3) Додати `sampleValues[]` у `ScopePlot` і заповнення в `timeStep()`.

Готовність: налаштування зберігаються/відновлюються, але ще не впливають на рендер.

### Етап 2 — Trigger detect + windowing у рендері
1) Реалізувати пошук triggerIndex по `sampleValues[]`.
2) Додати розрахунок `startIndexForDraw` (спільний для всіх каналів).
3) Підключити до `drawPlot()` через параметр `ipa`/`startIndex()` (потрібно дозволити override стартового індексу).

Готовність: при enable trigger сигнал стає стабільним на екрані.

### Етап 3 — Стани Auto/Normal/Single + Holdoff
1) Додати `triggerState` та логіку freeze.
2) Реалізувати holdoff і auto-timeout.

Готовність: `NORMAL` чекає, `AUTO` fallback’ить, `SINGLE` заморожує.

### Етап 4 — UI та оверлеї
1) Додати Trigger секцію в `ScopePropertiesDialog`.
2) Додати візуальні маркери (level line, trigger marker, статусний текст).

Готовність: користувач може налаштувати все без коду.

### Етап 5 — History/Persistence (накладання осцилограм)
1) Додати налаштування history у `Scope` (enable/depth/mode/plot).
2) Реалізувати capture кадру (manual + auto-on-trigger).
3) Додати рендер історії (перед поточним сигналом) з керованою “блідістю”.
4) Додати UI елементи `Capture/Clear` і `Depth`.

Готовність: можна накласти N осцилограм одного каналу і бачити їх розкид.

### Етап 6 — Регресія та тести
Тести/перевірки виконувати через Chrome DevTools згідно з `docs/JS_API.md`.

Рекомендований підхід:
- Завантажувати стандартні схеми з `src/main/java/com/lushprojects/circuitjs1/public/circuits` через JS API (каталог `tests` містить тимчасові файли і не використовується як джерело тестів).
- Перевірити типові сигнали: синус, меандр, імпульси, шум; повільні/швидкі timebase; AC-coupled trigger source.
- Переконатися, що non-trigger режими працюють як раніше.
- Окремо перевірити, що Roll (trigger disabled) та FFT (`showFFT`) поводяться так само, як до змін.
- Перевірити, що History/Persistence:
   - зберігає потрібну кількість кадрів
   - коректно очищається
   - працює тільки для одного вибраного каналу

## Ризики та edge cases
- **Min/max vs sample**: без `sampleValues[]` тригер буде нестабільним.
- **Змішання units**: якщо на scope одночасно V і A, вертикальна шкала/0-лінія ускладнюються. Trigger source має бути однозначним.
- **XY/FFT**: trigger не має сенсу — треба відключати.
- **Занадто малий holdoff**: флікер. Занадто великий — пропуски.
- **Decimation/aliasing**: при великому speed дрібні імпульси можуть “зникати” і тригер не знайдеться.
- **History продуктивність/пам’ять**: зберігання N кадрів у “піксельному” вигляді має лімітитись `historyDepth`, інакше буде зайве навантаження.

## Критерії готовності (DoD)
- Увімкнення trigger-mode робить хвилю стабільною на екрані (на періодичних сигналах).
- Працюють `AUTO`, `NORMAL`, `SINGLE`.
- Є керування `level`, `slope`, `source`, `trigger position`.
- Налаштування зберігаються у дампі схеми.
- Режими Roll (існуючий free-run) та FFT працюють без регресій.
- Є можливість накласти N осцилограм одного каналу (History/Persistence) і очистити історію.
